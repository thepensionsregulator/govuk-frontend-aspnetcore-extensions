@inherits Umbraco.Cms.Web.Common.Views.UmbracoViewPage<IEnumerable<BlockListItem>>
@using GovUk.Frontend.AspNetCore.Extensions;
@using GovUk.Frontend.Umbraco
@using GovUk.Frontend.Umbraco.Models
@using GovUk.Frontend.Umbraco.Services
@using System.Text.RegularExpressions
@using GovUk.Frontend.Umbraco.Validation;
@using Microsoft.AspNetCore.Mvc.ModelBinding
@using Umbraco.Cms.Core.Models.Blocks
@using Umbraco.Extensions
@{
    var filteredModel = Model as OverridableBlockListModel ?? new OverridableBlockListModel(Model, null);
    var blocks = filteredModel.FilteredBlocks().ToList();
    if (!blocks.Any()) { return; }
    string? previousRowClass = null, previousColumnClass = null;
    bool? previousIsGridRowBlock = null;

    // Task list summaries automatically count the tasks they summarise. However, the status of each task is likely to be set in the controller,
    // and this is the last point where we have access to the overridden properties of the tasks before rendering the task list summary.
    // So we have to query the tasks here and pass the result down to the task list summary, which we can do using ModelState.
    var taskListSummaries = blocks.FindBlocks(x => x.Content.ContentType.Alias == ElementTypeAliases.TaskListSummary);
    if (taskListSummaries.Any())
    {
        var tasks = blocks.FindBlocks(x => x.Content.ContentType.Alias == ElementTypeAliases.Task);
        var taskStatuses = tasks.Select(x => ((OverridableBlockListItem)x).Settings.Value<string>("status")).Where(x => !string.IsNullOrEmpty(x)).Select(x => Enum.Parse<TaskListTaskStatus>(x!.Replace(" ", string.Empty), true));
        foreach (var taskListSummary in taskListSummaries)
        {
            ViewContext.ModelState.SetInitialValue(taskListSummary.Content.Key.ToString(), string.Join(",", taskStatuses));
        }
    }
}
@* Renders a partial view for each block.
   Renders blocks within a GOV.UK grid row, except where that block is a 'govukGridRow' in which case that task is delegated.
   Combines sibling rows with identical classes to simplify the HTML, but also to reduce instances where the grid rows 
   interfere with the spacing between components. Spacing (particularly for inset text) can rely on margin collapsing and
   wrapping every component in a grid row prevents that from working because the components no longer directly follow each other.
*@
@for (var i = 0; i < blocks.Count; i++)
{
    var block = blocks[i];
    if (blocks[i]?.ContentUdi == null) { continue; }

    var isGridRowBlock = blocks[i].Content.ContentType.Alias == ElementTypeAliases.GridRow;
    string rowClass = GovUkGridClassBuilder.BuildGridRowClass(blocks[i].Settings?.Value<string>(PropertyAliases.CssClassesForRow));
    var columnClass = GovUkGridClassBuilder.BuildGridColumnClass(
                        blocks[i].Settings?.Value<string>(PropertyAliases.ColumnSize), 
                        blocks[i].Settings?.Value<string>(PropertyAliases.ColumnSizeFromDesktop), 
                        blocks[i].Settings?.Value<string>(PropertyAliases.CssClassesForColumn),
                        blocks[i].Content.ContentType.Alias);

    // If this block is a fieldset and there is a fieldset-level error, add extra classes to show that the entire fieldset is in an error state.
    // But only if the 'legendIsPageHeading' setting is false, otherwise it's done in GovUkFieldset.cshtml.
    var fieldsetErrors = GovUkFieldsetErrorFinder.FindFieldsetErrors(blocks[i], ViewContext.ModelState);
    string? fieldsetErrorClasses = null;
    if (fieldsetErrors.Any())
    {
        var legendIsPageHeading = blocks[i].Settings?.Value<bool>(PropertyAliases.FieldsetLegendIsPageHeading) ?? false;
        if (!legendIsPageHeading)
        {
            fieldsetErrorClasses = "govuk-form-group govuk-form-group--error";
        }
    }

    var sameAsPrevious = (isGridRowBlock == previousIsGridRowBlock && rowClass == previousRowClass && columnClass == previousColumnClass);

    var sameAsNext = (i < blocks.Count-1 &&
                          isGridRowBlock == (blocks[i + 1].Content.ContentType.Alias == ElementTypeAliases.GridRow) &&
                          rowClass == GovUkGridClassBuilder.BuildGridRowClass(blocks[i+1].Settings?.Value<string>(PropertyAliases.CssClassesForRow)) &&
                          columnClass == GovUkGridClassBuilder.BuildGridColumnClass(
                                                    blocks[i+1].Settings?.Value<string>(PropertyAliases.ColumnSize), 
                                                    blocks[i+1].Settings?.Value<string>(PropertyAliases.ColumnSizeFromDesktop), 
                                                    blocks[i+1].Settings?.Value<string>(PropertyAliases.CssClassesForColumn),
                                                    blocks[i+1].Content.ContentType.Alias));

    var pathToView = (blocks[i].Content.ContentType.Alias.StartsWith("GOVUK", StringComparison.OrdinalIgnoreCase) ? "GOVUK/" : "TPR/") + blocks[i].Content.ContentType.Alias;

    @if (filteredModel.RenderGrid && !isGridRowBlock && !sameAsPrevious) { 
        @:<div class="@rowClass"> 
        @:<div class="@columnClass"> 
    }
    @if (!string.IsNullOrEmpty(fieldsetErrorClasses))
    {
        @:<div class="@fieldsetErrorClasses"> 
    }
    @await Html.PartialAsync(pathToView, block)
    @if (!string.IsNullOrEmpty(fieldsetErrorClasses))
    {
        @:</div> 
    }
    @if (filteredModel.RenderGrid && !isGridRowBlock && !sameAsNext) {
        @:</div> 
        @:</div> 
    }

    previousIsGridRowBlock = isGridRowBlock;
    previousRowClass = rowClass;
    previousColumnClass = columnClass;
}